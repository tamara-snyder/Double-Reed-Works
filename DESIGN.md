I implemented my final project as a Flask application, taking advantage of Jinja templating to maintain a consistent appearance and format throughout the site.
The main html page of this application is trouble-shooter.html, which can be accessed by clicking "Get Started" on the home page. This page has a form with ten checkboxes representing common problems with bassoon reeds. When the user clicks "Submit", the main function in trouble-shooter.js, displayReedAdvice(), is called.
Also in trouble-shooter.js is a large dictionary entitled "solutions", where each key matches one of the checkbox values in trouble-shooter.html. The values of each key in the solutions dictionary are lists of dictionaries, where each dictionary in the list is a potential solution to the problem containing all the information to be dynamically displayed later in the JavaScript file. In each of these sub-dictionaries are keys for "problem", "text", "tools", and "image", and their values are all corresponding text or in the case of "image", a path to an image.
After the definition of solutions, I have a function entitled getCheckboxValues(), which goes through the checkboxes and creates an array of the values checked by the user. The function returns this array, which is crucial for indexing into solutions later on.
Next, I define a function, getReedAdvice(), which iterates through the checkbox values and indexes into solutions, storing all relevant information in a multi-dimensional array. This array consists of a top-level array of the problems checked by the user, with nested arrays containing values from the solutions dictionary.
In the next function, displayReedAdvice(), I call getReedAdvice() and assign the resulting array to the variable "userSolutions". I then get the necessary HTML elements from trouble-shooter.html, the innerHTML of which will be replaced later on. I also create an image element as a placeholder for the reed graphics I created for this project.
Next, displayReedAdvice() indexes into userSolutions and fills the innerHTML and image sources for the necessary elements. It also adds event listeners for "yes" and "no", which are the buttons that the user can press to give feedback about whether the displayed recommendation worked for them. If the user clicks "yes", they are saying that their reed has improved the variable currentProblem increments by one to index into the next problem in the checked list (if it exists). The same process goes for "no", where if the user does not think their reed has improved, currentSolution increments by one and displays the next available solution to the problem they are having (if it exists). If no more solutions exist, the event listener function moves on to the next problem in userSolutions, or if no problems remain, the function returns the user to the checkbox form.
Sadly, I eventually ran into a roadblock where once the event listener functions were called and the script stopped running, the altered DOM reverted to its original state and the next solutions did not remain on display, but instead went back to the blank checkbox form. I tried to remedy the situation by placing the event listeners in various scopes, adding a sleep function to the end of the script (a terrible idea, turns out), adding code to hide the checkbox form at the end of the file, and even spending several hours refactoring the code into app.py to be executed with two Flask templates, but I was unable to find an elegant solution before the deadline. I plan to solve this problem at another time, as I think this project will be really useful to bassoonists everywhere if I can implement it well.
Also included on the webpage under "Sources" are citations for the fantastic reed-making resources I consulted to design the flow of the trouble-shooter.